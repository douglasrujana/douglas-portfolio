---
title: 'Arquitectura Hexagonal: GuÃ­a Completa para Desarrolladores Modernos'
description: 'Aprende a implementar arquitectura hexagonal (Ports & Adapters) en tus proyectos. Desde los principios SOLID hasta ejemplos reales con TypeScript.'
author: 'Douglas Rujana'
publishedAt: 2025-01-15
category: 'architecture'
tags: ['arquitectura', 'clean-code', 'typescript', 'solid', 'design-patterns']
featured: true
draft: false
coverImage: 'https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?w=1200&h=630&fit=crop'
showToc: true
crosspost:
  linkedin: true
  twitter: true
  facebook: false
  devto: true
---

La **arquitectura hexagonal** (tambiÃ©n conocida como *Ports & Adapters*) es un patrÃ³n arquitectÃ³nico que te permite construir aplicaciones mantenibles, testables y completamente desacopladas de frameworks y tecnologÃ­as especÃ­ficas.

## Â¿Por quÃ© Arquitectura Hexagonal?

En proyectos tradicionales, es comÃºn ver cÃ³digo fuertemente acoplado a:
- Frameworks web (Express, NestJS, Laravel)
- Bases de datos especÃ­ficas (MySQL, MongoDB)
- APIs externas (Stripe, Twilio, AWS)

Este acoplamiento genera **vendor lock-in** y hace que:
- âŒ Migrar de tecnologÃ­a sea una pesadilla
- âŒ Los tests requieran infraestructura real
- âŒ La lÃ³gica de negocio se mezcle con detalles tÃ©cnicos

La arquitectura hexagonal soluciona esto **invirtiendo las dependencias**.

## Principios Fundamentales

### 1. Separation of Concerns

Divide tu aplicaciÃ³n en **3 capas**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PRESENTATION LAYER (UI/API)       â”‚  â† Adapters (entrada)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   APPLICATION LAYER (Use Cases)     â”‚  â† OrquestaciÃ³n
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   DOMAIN LAYER (Business Logic)     â”‚  â† Core (reglas de negocio)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   INFRASTRUCTURE LAYER (Adapters)   â”‚  â† Adapters (salida)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Dependency Inversion Principle (DIP)

Las capas superiores **no dependen** de las inferiores. Ambas dependen de **abstracciones** (interfaces).

```typescript
// âŒ MAL: Dependencia directa
class UserService {
  constructor(private db: MySQLDatabase) {}
}

// âœ… BIEN: Dependencia en abstracciÃ³n
interface IUserRepository {
  save(user: User): Promise<void>;
}

class UserService {
  constructor(private repo: IUserRepository) {}
}
```

## ImplementaciÃ³n PrÃ¡ctica

### Paso 1: Define el Puerto (Interface)

```typescript
// src/core/ports/ILLMProvider.ts
export interface ILLMProvider {
  generateResponse(prompt: string): Promise<string>;
}
```

### Paso 2: Crea el Adapter

```typescript
// src/infrastructure/adapters/GeminiAdapter.ts
import { ILLMProvider } from '@core/ports/ILLMProvider';

export class GeminiAdapter implements ILLMProvider {
  async generateResponse(prompt: string): Promise<string> {
    // ImplementaciÃ³n especÃ­fica de Gemini
    return "Respuesta...";
  }
}
```

### Paso 3: Usa el Factory Pattern

```typescript
// src/infrastructure/adapters/LLMFactory.ts
export class LLMFactory {
  static create(provider: 'gemini' | 'openai'): ILLMProvider {
    switch (provider) {
      case 'gemini':
        return new GeminiAdapter();
      case 'openai':
        return new OpenAIAdapter();
    }
  }
}
```

### Paso 4: Inyecta la Dependencia

```typescript
// src/application/use-cases/GenerateResponse.ts
export class GenerateResponseUseCase {
  constructor(private llm: ILLMProvider) {}
  
  async execute(prompt: string): Promise<string> {
    return await this.llm.generateResponse(prompt);
  }
}
```

## Ventajas Reales

### ğŸ§ª Testing Simplificado

```typescript
// Mock del adapter sin infraestructura real
class MockLLMProvider implements ILLMProvider {
  async generateResponse(prompt: string): Promise<string> {
    return "Mock response";
  }
}

// Test unitario
const useCase = new GenerateResponseUseCase(new MockLLMProvider());
const result = await useCase.execute("test");
expect(result).toBe("Mock response");
```

### ğŸ”„ Zero Vendor Lock-in

Cambias de Gemini a OpenAI en **2 lÃ­neas**:

```typescript
// Antes
const llm = LLMFactory.create('gemini', { apiKey: key });

// DespuÃ©s
const llm = LLMFactory.create('openai', { apiKey: key });
```

Todo el resto del cÃ³digo **permanece intacto**.

### ğŸ“¦ Portabilidad Total

Tu aplicaciÃ³n funciona en:
- âœ… Vercel
- âœ… Netlify
- âœ… AWS Lambda
- âœ… Docker self-hosted

Solo cambias el adapter de deployment.

## Errores Comunes

### âŒ Layers que "saltan"

```typescript
// MAL: Presentation llama directamente a Infrastructure
import { MySQLDatabase } from '@infrastructure/db';

export function handler(req, res) {
  const db = new MySQLDatabase();
  // ...
}
```

**SoluciÃ³n:** Siempre pasar por Application Layer.

### âŒ LÃ³gica de negocio en Adapters

```typescript
// MAL: ValidaciÃ³n en el adapter
class UserRepository {
  async save(user: User) {
    if (!user.email.includes('@')) {
      throw new Error('Invalid email');
    }
    // ...
  }
}
```

**SoluciÃ³n:** ValidaciÃ³n en Domain Layer (Entities/Value Objects).

## ConclusiÃ³n

La arquitectura hexagonal requiere mÃ¡s setup inicial, pero te da:
- âœ… CÃ³digo mantenible a largo plazo
- âœ… Tests rÃ¡pidos y confiables
- âœ… Flexibilidad para cambiar tecnologÃ­as
- âœ… SeparaciÃ³n clara de responsabilidades

Es la diferencia entre cÃ³digo que **sobrevive 10 aÃ±os** vs cÃ³digo que hay que reescribir cada 2 aÃ±os.

## Recursos

- [Hexagonal Architecture by Alistair Cockburn](https://alistair.cockburn.us/hexagonal-architecture/)
- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Ejemplo completo en GitHub](https://github.com/douglasrujana/hexagonal-example)

---

Â¿Implementas arquitectura hexagonal en tus proyectos? Â¿QuÃ© otros patrones arquitectÃ³nicos usas? DÃ©jame tus comentarios.
